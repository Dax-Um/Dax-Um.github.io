<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Activity | Dax의 조용한 개발 서랍</title><meta name=keywords content="android component"><meta name=description content="🖥️ Android Activity 완벽 가이드 (2025년 기준)
Android 앱의 핵심 구성 요소인 Activity는 사용자와 직접 상호작용하는 단일 UI 화면을 나타냅니다. Activity는 앱이 사용자에게 보여주는 각각의 화면을 담당하며, 생명주기를 통해 시스템 이벤트에 반응하고 사용자 경험을 관리합니다.

📌 Activity란?

앱의 UI 단위 구성 요소이며, 사용자에게 제공되는 하나의 화면을 의미합니다.
앱 내의 여러 Activity는 사용자 흐름에 따라 서로 전환되며, 각각의 Activity는 독립된 생명주기를 가집니다.
일반적으로 MainActivity가 진입점이 되며, 이후 필요한 Activity를 Intent를 통해 실행합니다.

대표적인 Activity 예시

로그인 화면 (LoginActivity)
홈 화면 (HomeActivity)
상세 정보 화면 (DetailActivity)


🧬 생명주기 구조

📌 실무에서는? Jetpack 아키텍처 컴포넌트를 활용해 생명주기 콜백을 직접 사용하는 비중은 줄고, 대부분 repeatOnLifecycle, ViewModel, LifecycleObserver를 사용해 간접적으로 관리합니다. 하지만 생명주기 구조를 이해하는 것은 여전히 중요하며, 정확한 리소스 해제, 센서 관리, 화면 상태 복원 등에 필수적입니다."><meta name=author content><link rel=canonical href=https://Dax-Um.github.io/posts/activity/><link crossorigin=anonymous href=/assets/css/stylesheet.a34fb64a5c0349120fabeffb80ef064b35a4b87fd5a12cb40a088e9a93053d51.css integrity="sha256-o0+2SlwDSRIPq+/7gO8GSzWkuH/VoSy0CgiOmpMFPVE=" rel="preload stylesheet" as=style><link rel=icon href=https://Dax-Um.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://Dax-Um.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://Dax-Um.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://Dax-Um.github.io/apple-touch-icon.png><link rel=mask-icon href=https://Dax-Um.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://Dax-Um.github.io/posts/activity/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://Dax-Um.github.io/posts/activity/"><meta property="og:site_name" content="Dax의 조용한 개발 서랍"><meta property="og:title" content="Activity"><meta property="og:description" content="🖥️ Android Activity 완벽 가이드 (2025년 기준) Android 앱의 핵심 구성 요소인 Activity는 사용자와 직접 상호작용하는 단일 UI 화면을 나타냅니다. Activity는 앱이 사용자에게 보여주는 각각의 화면을 담당하며, 생명주기를 통해 시스템 이벤트에 반응하고 사용자 경험을 관리합니다.
📌 Activity란? 앱의 UI 단위 구성 요소이며, 사용자에게 제공되는 하나의 화면을 의미합니다. 앱 내의 여러 Activity는 사용자 흐름에 따라 서로 전환되며, 각각의 Activity는 독립된 생명주기를 가집니다. 일반적으로 MainActivity가 진입점이 되며, 이후 필요한 Activity를 Intent를 통해 실행합니다. 대표적인 Activity 예시 로그인 화면 (LoginActivity) 홈 화면 (HomeActivity) 상세 정보 화면 (DetailActivity) 🧬 생명주기 구조 📌 실무에서는? Jetpack 아키텍처 컴포넌트를 활용해 생명주기 콜백을 직접 사용하는 비중은 줄고, 대부분 repeatOnLifecycle, ViewModel, LifecycleObserver를 사용해 간접적으로 관리합니다. 하지만 생명주기 구조를 이해하는 것은 여전히 중요하며, 정확한 리소스 해제, 센서 관리, 화면 상태 복원 등에 필수적입니다."><meta property="og:locale" content="ko-kr"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-09T00:00:00+00:00"><meta property="article:modified_time" content="2025-06-09T00:00:00+00:00"><meta property="article:tag" content="Android Component"><meta name=twitter:card content="summary"><meta name=twitter:title content="Activity"><meta name=twitter:description content="🖥️ Android Activity 완벽 가이드 (2025년 기준)
Android 앱의 핵심 구성 요소인 Activity는 사용자와 직접 상호작용하는 단일 UI 화면을 나타냅니다. Activity는 앱이 사용자에게 보여주는 각각의 화면을 담당하며, 생명주기를 통해 시스템 이벤트에 반응하고 사용자 경험을 관리합니다.

📌 Activity란?

앱의 UI 단위 구성 요소이며, 사용자에게 제공되는 하나의 화면을 의미합니다.
앱 내의 여러 Activity는 사용자 흐름에 따라 서로 전환되며, 각각의 Activity는 독립된 생명주기를 가집니다.
일반적으로 MainActivity가 진입점이 되며, 이후 필요한 Activity를 Intent를 통해 실행합니다.

대표적인 Activity 예시

로그인 화면 (LoginActivity)
홈 화면 (HomeActivity)
상세 정보 화면 (DetailActivity)


🧬 생명주기 구조

📌 실무에서는? Jetpack 아키텍처 컴포넌트를 활용해 생명주기 콜백을 직접 사용하는 비중은 줄고, 대부분 repeatOnLifecycle, ViewModel, LifecycleObserver를 사용해 간접적으로 관리합니다. 하지만 생명주기 구조를 이해하는 것은 여전히 중요하며, 정확한 리소스 해제, 센서 관리, 화면 상태 복원 등에 필수적입니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://Dax-Um.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Activity","item":"https://Dax-Um.github.io/posts/activity/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Activity","name":"Activity","description":"🖥️ Android Activity 완벽 가이드 (2025년 기준) Android 앱의 핵심 구성 요소인 Activity는 사용자와 직접 상호작용하는 단일 UI 화면을 나타냅니다. Activity는 앱이 사용자에게 보여주는 각각의 화면을 담당하며, 생명주기를 통해 시스템 이벤트에 반응하고 사용자 경험을 관리합니다.\n📌 Activity란? 앱의 UI 단위 구성 요소이며, 사용자에게 제공되는 하나의 화면을 의미합니다. 앱 내의 여러 Activity는 사용자 흐름에 따라 서로 전환되며, 각각의 Activity는 독립된 생명주기를 가집니다. 일반적으로 MainActivity가 진입점이 되며, 이후 필요한 Activity를 Intent를 통해 실행합니다. 대표적인 Activity 예시 로그인 화면 (LoginActivity) 홈 화면 (HomeActivity) 상세 정보 화면 (DetailActivity) 🧬 생명주기 구조 📌 실무에서는? Jetpack 아키텍처 컴포넌트를 활용해 생명주기 콜백을 직접 사용하는 비중은 줄고, 대부분 repeatOnLifecycle, ViewModel, LifecycleObserver를 사용해 간접적으로 관리합니다. 하지만 생명주기 구조를 이해하는 것은 여전히 중요하며, 정확한 리소스 해제, 센서 관리, 화면 상태 복원 등에 필수적입니다.\n","keywords":["android component"],"articleBody":"🖥️ Android Activity 완벽 가이드 (2025년 기준) Android 앱의 핵심 구성 요소인 Activity는 사용자와 직접 상호작용하는 단일 UI 화면을 나타냅니다. Activity는 앱이 사용자에게 보여주는 각각의 화면을 담당하며, 생명주기를 통해 시스템 이벤트에 반응하고 사용자 경험을 관리합니다.\n📌 Activity란? 앱의 UI 단위 구성 요소이며, 사용자에게 제공되는 하나의 화면을 의미합니다. 앱 내의 여러 Activity는 사용자 흐름에 따라 서로 전환되며, 각각의 Activity는 독립된 생명주기를 가집니다. 일반적으로 MainActivity가 진입점이 되며, 이후 필요한 Activity를 Intent를 통해 실행합니다. 대표적인 Activity 예시 로그인 화면 (LoginActivity) 홈 화면 (HomeActivity) 상세 정보 화면 (DetailActivity) 🧬 생명주기 구조 📌 실무에서는? Jetpack 아키텍처 컴포넌트를 활용해 생명주기 콜백을 직접 사용하는 비중은 줄고, 대부분 repeatOnLifecycle, ViewModel, LifecycleObserver를 사용해 간접적으로 관리합니다. 하지만 생명주기 구조를 이해하는 것은 여전히 중요하며, 정확한 리소스 해제, 센서 관리, 화면 상태 복원 등에 필수적입니다.\nActivity의 생명주기는 단순히 시스템 콜백을 받는 것 이상의 의미를 가지며, 적절한 리소스 관리, 데이터 저장/복원, 사용자 경험 최적화를 위해 중요한 역할을 합니다.\n다음은 각 생명주기 단계에서 일반적으로 수행하는 작업과 앱 최적화를 위한 권장 구현입니다:\nActivity는 다음과 같은 생명주기 콜백을 통해 시스템 상태 변화에 대응합니다:\n메서드 설명 onCreate() 최초 생성 시 호출. UI 초기화 및 리소스 설정 onStart() Activity가 사용자에게 표시되기 직전 호출 onResume() 사용자와 상호작용 가능한 상태. 포커스 있음 onPause() 포커스를 잃었지만 여전히 화면에 존재할 수 있음 onStop() 완전히 화면에서 사라짐. UI 비활성화 onDestroy() Activity 종료 및 리소스 해제 단계 🔁 생명주기 흐름 예시 및 구현 가이드 (상세 예시 포함) ✅ 실무에서는 대부분 아래와 같은 직접적인 콜백 구현보다는 ViewModel + repeatOnLifecycle 구조를 사용합니다. 하지만 센서, 카메라, 오디오 등 명확한 시점 제어가 필요한 경우에는 여전히 생명주기 콜백을 적절히 활용합니다.\n콜백 메서드 일반적 구현 내용 앱 최적화를 위한 팁 onCreate() View Binding, 초기 데이터 설정, ViewModel 연결 네트워크 초기 요청이나 Room 쿼리 같은 무거운 작업은 lifecycleScope.launch {}로 비동기 처리하거나 Splash Screen과 결합하여 UX 향상 onStart() UI 업데이트, Google Analytics 또는 Firebase Analytics 로그 전송 사용자에게 표시되기 직전이므로 카메라 프리뷰 준비, 위치 권한 체크 등을 이 시점에 배치 onResume() 카메라 시작, 센서 활성화, 광고 로딩 재개 이 시점은 사용자와 직접 상호작용 가능한 상태이므로, 앱 주요 기능을 본격적으로 활성화 onPause() 센서 정지, MediaPlayer 정지, 저장되지 않은 임시 데이터 보존 리소스 소모 높은 기능을 최소화하고, 잠재적 사용자 데이터 유실을 방지 onStop() 알림 중지, Room DB에 캐시 저장, 카메라 해제 사용자가 화면을 완전히 벗어난 시점이므로, 데이터 동기화나 서버 전송 처리 등에 적합 onDestroy() View 정리, 리스너 및 콜백 제거, 서비스 언바인딩 BroadcastReceiver 등록 해제, 내부 참조 null 처리 등을 통해 메모리 누수 방지 콜백마다 책임을 명확히 분리하면 생명주기 변화에 따른 크래시를 방지할 수 있고, 배터리와 메모리 사용을 최소화하여 앱의 전반적인 성능과 사용자 경험을 개선할 수 있습니다.\n예를 들어, onPause 시점에 동영상 재생을 일시 정지하지 않으면 앱이 백그라운드에 있음에도 리소스를 계속 소비하여 배터리를 낭비할 수 있습니다. 또는 onDestroy에서 리스너나 콜백을 해제하지 않으면 메모리 누수(leak)가 발생해 장기적으로 앱 안정성이 떨어질 수 있습니다.\nJetpack의 LifecycleObserver 또는 LifecycleOwner를 사용하는 구조화된 방식도 함께 고려해보세요. 실무에서는 다음과 같은 코드로 생명주기를 간접적으로 관리합니다:\nlifecycleScope.launch { repeatOnLifecycle(Lifecycle.State.STARTED) { viewModel.uiState.collect { state -\u003e render(state) } } } 이 구조는 Activity의 onStart, onStop을 자동으로 감지하여 Flow 또는 LiveData 관찰을 중단/재개합니다. 복잡한 생명주기 관리를 단순화시킬 수 있어 실무에서 매우 널리 사용됩니다.\noverride fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) Log.d(\"Lifecycle\", \"onCreate 호출\") } override fun onStart() { super.onStart() Log.d(\"Lifecycle\", \"onStart 호출\") } override fun onResume() { super.onResume() Log.d(\"Lifecycle\", \"onResume 호출\") } 📘 공식 Lifecycle 다이어그램 보기\n🧾 AndroidManifest.xml 등록 예시 ","wordCount":"1119","inLanguage":"en","datePublished":"2025-06-09T00:00:00Z","dateModified":"2025-06-09T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://Dax-Um.github.io/posts/activity/"},"publisher":{"@type":"Organization","name":"Dax의 조용한 개발 서랍","logo":{"@type":"ImageObject","url":"https://Dax-Um.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://Dax-Um.github.io/ accesskey=h title="Dax의 조용한 개발 서랍 (Alt + H)">Dax의 조용한 개발 서랍</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://Dax-Um.github.io/about title=Resume><span>Resume</span></a></li><li><a href=https://Dax-Um.github.io/categories/android title=Android><span>Android</span></a></li><li><a href=https://Dax-Um.github.io/categories/jetpack-compose title="Jetpack Compose"><span>Jetpack Compose</span></a></li><li><a href=https://Dax-Um.github.io/categories/kotlin title=Kotlin><span>Kotlin</span></a></li><li><a href=https://Dax-Um.github.io/categories/java title=Java><span>Java</span></a></li><li><a href=https://Dax-Um.github.io/categories/tdd title=TDD><span>TDD</span></a></li><li><a href=https://Dax-Um.github.io/categories/architecture title=Architecture><span>Architecture</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Activity</h1><div class=post-meta><span title='2025-06-09 00:00:00 +0000 UTC'>June 9, 2025</span>&nbsp;·&nbsp;6 min</div></header><div class=post-content><h1 id=-android-activity-완벽-가이드-2025년-기준>🖥️ Android Activity 완벽 가이드 (2025년 기준)<a hidden class=anchor aria-hidden=true href=#-android-activity-완벽-가이드-2025년-기준>#</a></h1><p>Android 앱의 핵심 구성 요소인 <strong>Activity</strong>는 사용자와 직접 상호작용하는 단일 UI 화면을 나타냅니다. Activity는 앱이 사용자에게 보여주는 <strong>각각의 화면</strong>을 담당하며, 생명주기를 통해 시스템 이벤트에 반응하고 사용자 경험을 관리합니다.</p><hr><h2 id=-activity란>📌 Activity란?<a hidden class=anchor aria-hidden=true href=#-activity란>#</a></h2><ul><li>앱의 <strong>UI 단위 구성 요소</strong>이며, 사용자에게 제공되는 하나의 화면을 의미합니다.</li><li>앱 내의 여러 Activity는 사용자 흐름에 따라 서로 전환되며, 각각의 Activity는 독립된 생명주기를 가집니다.</li><li>일반적으로 <code>MainActivity</code>가 진입점이 되며, 이후 필요한 Activity를 <code>Intent</code>를 통해 실행합니다.</li></ul><h3 id=대표적인-activity-예시>대표적인 Activity 예시<a hidden class=anchor aria-hidden=true href=#대표적인-activity-예시>#</a></h3><ul><li>로그인 화면 (<code>LoginActivity</code>)</li><li>홈 화면 (<code>HomeActivity</code>)</li><li>상세 정보 화면 (<code>DetailActivity</code>)</li></ul><hr><h2 id=-생명주기-구조>🧬 생명주기 구조<a hidden class=anchor aria-hidden=true href=#-생명주기-구조>#</a></h2><blockquote><p>📌 <strong>실무에서는?</strong> Jetpack 아키텍처 컴포넌트를 활용해 생명주기 콜백을 직접 사용하는 비중은 줄고, 대부분 <code>repeatOnLifecycle</code>, <code>ViewModel</code>, <code>LifecycleObserver</code>를 사용해 간접적으로 관리합니다. 하지만 생명주기 구조를 이해하는 것은 여전히 중요하며, 정확한 리소스 해제, 센서 관리, 화면 상태 복원 등에 필수적입니다.</p></blockquote><p>Activity의 생명주기는 단순히 시스템 콜백을 받는 것 이상의 의미를 가지며, <strong>적절한 리소스 관리</strong>, <strong>데이터 저장/복원</strong>, <strong>사용자 경험 최적화</strong>를 위해 중요한 역할을 합니다.</p><p>다음은 각 생명주기 단계에서 일반적으로 수행하는 작업과 앱 최적화를 위한 권장 구현입니다:</p><p>Activity는 다음과 같은 생명주기 콜백을 통해 시스템 상태 변화에 대응합니다:</p><table><thead><tr><th>메서드</th><th>설명</th></tr></thead><tbody><tr><td><code>onCreate()</code></td><td>최초 생성 시 호출. UI 초기화 및 리소스 설정</td></tr><tr><td><code>onStart()</code></td><td>Activity가 사용자에게 표시되기 직전 호출</td></tr><tr><td><code>onResume()</code></td><td>사용자와 상호작용 가능한 상태. 포커스 있음</td></tr><tr><td><code>onPause()</code></td><td>포커스를 잃었지만 여전히 화면에 존재할 수 있음</td></tr><tr><td><code>onStop()</code></td><td>완전히 화면에서 사라짐. UI 비활성화</td></tr><tr><td><code>onDestroy()</code></td><td>Activity 종료 및 리소스 해제 단계</td></tr></tbody></table><h3 id=-생명주기-흐름-예시-및-구현-가이드-상세-예시-포함>🔁 생명주기 흐름 예시 및 구현 가이드 (상세 예시 포함)<a hidden class=anchor aria-hidden=true href=#-생명주기-흐름-예시-및-구현-가이드-상세-예시-포함>#</a></h3><blockquote><p>✅ 실무에서는 대부분 아래와 같은 직접적인 콜백 구현보다는 ViewModel + repeatOnLifecycle 구조를 사용합니다. 하지만 센서, 카메라, 오디오 등 명확한 시점 제어가 필요한 경우에는 여전히 생명주기 콜백을 적절히 활용합니다.</p></blockquote><table><thead><tr><th>콜백 메서드</th><th>일반적 구현 내용</th><th>앱 최적화를 위한 팁</th></tr></thead><tbody><tr><td><code>onCreate()</code></td><td>View Binding, 초기 데이터 설정, ViewModel 연결</td><td>네트워크 초기 요청이나 Room 쿼리 같은 무거운 작업은 <code>lifecycleScope.launch {}</code>로 비동기 처리하거나 Splash Screen과 결합하여 UX 향상</td></tr><tr><td><code>onStart()</code></td><td>UI 업데이트, Google Analytics 또는 Firebase Analytics 로그 전송</td><td>사용자에게 표시되기 직전이므로 카메라 프리뷰 준비, 위치 권한 체크 등을 이 시점에 배치</td></tr><tr><td><code>onResume()</code></td><td>카메라 시작, 센서 활성화, 광고 로딩 재개</td><td>이 시점은 사용자와 직접 상호작용 가능한 상태이므로, 앱 주요 기능을 본격적으로 활성화</td></tr><tr><td><code>onPause()</code></td><td>센서 정지, MediaPlayer 정지, 저장되지 않은 임시 데이터 보존</td><td>리소스 소모 높은 기능을 최소화하고, 잠재적 사용자 데이터 유실을 방지</td></tr><tr><td><code>onStop()</code></td><td>알림 중지, Room DB에 캐시 저장, 카메라 해제</td><td>사용자가 화면을 완전히 벗어난 시점이므로, 데이터 동기화나 서버 전송 처리 등에 적합</td></tr><tr><td><code>onDestroy()</code></td><td>View 정리, 리스너 및 콜백 제거, 서비스 언바인딩</td><td><code>BroadcastReceiver</code> 등록 해제, 내부 참조 null 처리 등을 통해 메모리 누수 방지</td></tr></tbody></table><p>콜백마다 책임을 명확히 분리하면 생명주기 변화에 따른 크래시를 방지할 수 있고, 배터리와 메모리 사용을 최소화하여 앱의 전반적인 성능과 사용자 경험을 개선할 수 있습니다.</p><p>예를 들어, onPause 시점에 동영상 재생을 일시 정지하지 않으면 앱이 백그라운드에 있음에도 리소스를 계속 소비하여 배터리를 낭비할 수 있습니다. 또는 onDestroy에서 리스너나 콜백을 해제하지 않으면 메모리 누수(leak)가 발생해 장기적으로 앱 안정성이 떨어질 수 있습니다.</p><p>Jetpack의 LifecycleObserver 또는 LifecycleOwner를 사용하는 구조화된 방식도 함께 고려해보세요. 실무에서는 다음과 같은 코드로 생명주기를 간접적으로 관리합니다:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=n>lifecycleScope</span><span class=p>.</span><span class=n>launch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>repeatOnLifecycle</span><span class=p>(</span><span class=nc>Lifecycle</span><span class=p>.</span><span class=nc>State</span><span class=p>.</span><span class=n>STARTED</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>viewModel</span><span class=p>.</span><span class=n>uiState</span><span class=p>.</span><span class=n>collect</span> <span class=p>{</span> <span class=n>state</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>            <span class=n>render</span><span class=p>(</span><span class=n>state</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>이 구조는 Activity의 <code>onStart</code>, <code>onStop</code>을 자동으로 감지하여 Flow 또는 LiveData 관찰을 중단/재개합니다. 복잡한 생명주기 관리를 단순화시킬 수 있어 실무에서 매우 널리 사용됩니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>override</span> <span class=k>fun</span> <span class=nf>onCreate</span><span class=p>(</span><span class=n>savedInstanceState</span><span class=p>:</span> <span class=n>Bundle</span><span class=p>?)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>super</span><span class=p>.</span><span class=n>onCreate</span><span class=p>(</span><span class=n>savedInstanceState</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>setContentView</span><span class=p>(</span><span class=nc>R</span><span class=p>.</span><span class=n>layout</span><span class=p>.</span><span class=n>activity_main</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nc>Log</span><span class=p>.</span><span class=n>d</span><span class=p>(</span><span class=s2>&#34;Lifecycle&#34;</span><span class=p>,</span> <span class=s2>&#34;onCreate 호출&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>override</span> <span class=k>fun</span> <span class=nf>onStart</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>super</span><span class=p>.</span><span class=n>onStart</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nc>Log</span><span class=p>.</span><span class=n>d</span><span class=p>(</span><span class=s2>&#34;Lifecycle&#34;</span><span class=p>,</span> <span class=s2>&#34;onStart 호출&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>override</span> <span class=k>fun</span> <span class=nf>onResume</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>super</span><span class=p>.</span><span class=n>onResume</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nc>Log</span><span class=p>.</span><span class=n>d</span><span class=p>(</span><span class=s2>&#34;Lifecycle&#34;</span><span class=p>,</span> <span class=s2>&#34;onResume 호출&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>📘 <a href=https://developer.android.com/guide/components/activities/activity-lifecycle#lc>공식 Lifecycle 다이어그램 보기</a></p><hr><h2 id=-androidmanifestxml-등록-예시>🧾 AndroidManifest.xml 등록 예시<a hidden class=anchor aria-hidden=true href=#-androidmanifestxml-등록-예시>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;activity</span>
</span></span><span class=line><span class=cl>    <span class=na>android:name=</span><span class=s>&#34;.MainActivity&#34;</span>
</span></span><span class=line><span class=cl>    <span class=na>android:exported=</span><span class=s>&#34;true&#34;</span><span class=nt>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;intent-filter&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;action</span> <span class=na>android:name=</span><span class=s>&#34;android.intent.action.MAIN&#34;</span> <span class=nt>/&gt;</span>
</span></span><span class=line><span class=cl>        <span class=nt>&lt;category</span> <span class=na>android:name=</span><span class=s>&#34;android.intent.category.LAUNCHER&#34;</span> <span class=nt>/&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;/intent-filter&gt;</span>
</span></span><span class=line><span class=cl><span class=nt>&lt;/activity&gt;</span>
</span></span></code></pre></div><ul><li><code>android:exported="true"</code>는 Android 12(API 31) 이상에서 <strong>필수</strong>입니다.</li><li><code>MAIN</code> + <code>LAUNCHER</code>는 앱 실행 시 가장 먼저 실행되는 액티비티임을 의미합니다.</li></ul><hr><h2 id=-edge-to-edge-ui-대응-android-14>🧱 Edge-to-Edge UI 대응 (Android 14+)<a hidden class=anchor aria-hidden=true href=#-edge-to-edge-ui-대응-android-14>#</a></h2><p>Android 14부터는 시스템 UI (상태바, 내비게이션 바 등)까지 콘텐츠가 확장되는 <strong>Edge-to-Edge</strong> 구성이 기본입니다. <code>WindowInsets</code> 처리를 통해 레이아웃의 경계 패딩을 수동으로 조정해야 합니다.</p><h3 id=-view-기반-대응>✅ View 기반 대응<a hidden class=anchor aria-hidden=true href=#-view-기반-대응>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=nc>WindowCompat</span><span class=p>.</span><span class=n>setDecorFitsSystemWindows</span><span class=p>(</span><span class=n>window</span><span class=p>,</span> <span class=k>false</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>WindowInsetsControllerCompat</span><span class=p>(</span><span class=n>window</span><span class=p>,</span> <span class=n>window</span><span class=p>.</span><span class=n>decorView</span><span class=p>).</span><span class=n>isAppearanceLightStatusBars</span> <span class=p>=</span> <span class=k>true</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nc>ViewCompat</span><span class=p>.</span><span class=n>setOnApplyWindowInsetsListener</span><span class=p>(</span><span class=n>rootView</span><span class=p>)</span> <span class=p>{</span> <span class=n>view</span><span class=p>,</span> <span class=n>insets</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>bars</span> <span class=p>=</span> <span class=n>insets</span><span class=p>.</span><span class=n>getInsets</span><span class=p>(</span><span class=nc>WindowInsetsCompat</span><span class=p>.</span><span class=nc>Type</span><span class=p>.</span><span class=n>systemBars</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>view</span><span class=p>.</span><span class=n>setPadding</span><span class=p>(</span><span class=n>bars</span><span class=p>.</span><span class=n>left</span><span class=p>,</span> <span class=n>bars</span><span class=p>.</span><span class=n>top</span><span class=p>,</span> <span class=n>bars</span><span class=p>.</span><span class=n>right</span><span class=p>,</span> <span class=n>bars</span><span class=p>.</span><span class=n>bottom</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>insets</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=-jetpack-compose-기반-대응>✅ Jetpack Compose 기반 대응<a hidden class=anchor aria-hidden=true href=#-jetpack-compose-기반-대응>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=nc>WindowCompat</span><span class=p>.</span><span class=n>setDecorFitsSystemWindows</span><span class=p>(</span><span class=n>window</span><span class=p>,</span> <span class=k>false</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Scaffold</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>topBar</span> <span class=p>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>TopAppBar</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>title</span> <span class=p>=</span> <span class=p>{</span> <span class=n>Text</span><span class=p>(</span><span class=s2>&#34;Edge-to-Edge 대응&#34;</span><span class=p>)</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>            <span class=n>modifier</span> <span class=p>=</span> <span class=nc>Modifier</span><span class=p>.</span><span class=n>windowInsetsPadding</span><span class=p>(</span><span class=nc>WindowInsets</span><span class=p>.</span><span class=n>statusBars</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=n>content</span> <span class=p>=</span> <span class=p>{</span> <span class=n>innerPadding</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=n>Column</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=n>modifier</span> <span class=p>=</span> <span class=n>Modifier</span>
</span></span><span class=line><span class=cl>                <span class=p>.</span><span class=n>fillMaxSize</span><span class=p>()</span>
</span></span><span class=line><span class=cl>                <span class=p>.</span><span class=n>padding</span><span class=p>(</span><span class=n>innerPadding</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>.</span><span class=n>windowInsetsPadding</span><span class=p>(</span><span class=nc>WindowInsets</span><span class=p>.</span><span class=n>navigationBars</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Text</span><span class=p>(</span><span class=s2>&#34;Edge-to-Edge 적용된 화면&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>📘 <a href=https://developer.android.com/develop/ui/views/layout/insets-controller#compose>Inset 공식 가이드</a></p><hr><h2 id=-activity에서-intent로-화면-전환하기>🎯 Activity에서 Intent로 화면 전환하기<a hidden class=anchor aria-hidden=true href=#-activity에서-intent로-화면-전환하기>#</a></h2><p>Activity 간 화면 이동은 <code>Intent</code> 객체를 생성하여 수행합니다. 다음은 주요 상황별 예시입니다:</p><h3 id=-기본-화면-전환>✅ 기본 화면 전환<a hidden class=anchor aria-hidden=true href=#-기본-화면-전환>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>intent</span> <span class=p>=</span> <span class=n>Intent</span><span class=p>(</span><span class=k>this</span><span class=p>,</span> <span class=n>DetailActivity</span><span class=o>::</span><span class=k>class</span><span class=p>.</span><span class=n>java</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>startActivity</span><span class=p>(</span><span class=n>intent</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=-데이터-전달하기>✅ 데이터 전달하기<a hidden class=anchor aria-hidden=true href=#-데이터-전달하기>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>intent</span> <span class=p>=</span> <span class=n>Intent</span><span class=p>(</span><span class=k>this</span><span class=p>,</span> <span class=n>DetailActivity</span><span class=o>::</span><span class=k>class</span><span class=p>.</span><span class=n>java</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>intent</span><span class=p>.</span><span class=n>putExtra</span><span class=p>(</span><span class=s2>&#34;itemId&#34;</span><span class=p>,</span> <span class=m>123</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>intent</span><span class=p>.</span><span class=n>putExtra</span><span class=p>(</span><span class=s2>&#34;itemName&#34;</span><span class=p>,</span> <span class=s2>&#34;Notebook&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>startActivity</span><span class=p>(</span><span class=n>intent</span><span class=p>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=c1>// DetailActivity.kt
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>val</span> <span class=py>itemId</span> <span class=p>=</span> <span class=n>intent</span><span class=p>.</span><span class=n>getIntExtra</span><span class=p>(</span><span class=s2>&#34;itemId&#34;</span><span class=p>,</span> <span class=p>-</span><span class=m>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>itemName</span> <span class=p>=</span> <span class=n>intent</span><span class=p>.</span><span class=n>getStringExtra</span><span class=p>(</span><span class=s2>&#34;itemName&#34;</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=-activity-종료-후-결과-받기-startactivityforresult--registerforactivityresult>✅ Activity 종료 후 결과 받기 (startActivityForResult → registerForActivityResult)<a hidden class=anchor aria-hidden=true href=#-activity-종료-후-결과-받기-startactivityforresult--registerforactivityresult>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>launcher</span> <span class=p>=</span> <span class=n>registerForActivityResult</span><span class=p>(</span><span class=nc>ActivityResultContracts</span><span class=p>.</span><span class=n>StartActivityForResult</span><span class=p>())</span> <span class=p>{</span> <span class=n>result</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>result</span><span class=p>.</span><span class=n>resultCode</span> <span class=o>==</span> <span class=nc>Activity</span><span class=p>.</span><span class=n>RESULT_OK</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>val</span> <span class=py>data</span> <span class=p>=</span> <span class=n>result</span><span class=p>.</span><span class=k>data</span><span class=o>?.</span><span class=n>getStringExtra</span><span class=p>(</span><span class=s2>&#34;result&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nc>Log</span><span class=p>.</span><span class=n>d</span><span class=p>(</span><span class=s2>&#34;ActivityResult&#34;</span><span class=p>,</span> <span class=s2>&#34;결과: </span><span class=si>$data</span><span class=s2>&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>intent</span> <span class=p>=</span> <span class=n>Intent</span><span class=p>(</span><span class=k>this</span><span class=p>,</span> <span class=n>EditActivity</span><span class=o>::</span><span class=k>class</span><span class=p>.</span><span class=n>java</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>launcher</span><span class=p>.</span><span class=n>launch</span><span class=p>(</span><span class=n>intent</span><span class=p>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=c1>// EditActivity.kt
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>val</span> <span class=py>resultIntent</span> <span class=p>=</span> <span class=n>Intent</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>resultIntent</span><span class=p>.</span><span class=n>putExtra</span><span class=p>(</span><span class=s2>&#34;result&#34;</span><span class=p>,</span> <span class=s2>&#34;저장 완료&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>setResult</span><span class=p>(</span><span class=nc>Activity</span><span class=p>.</span><span class=n>RESULT_OK</span><span class=p>,</span> <span class=n>resultIntent</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>finish</span><span class=p>()</span>
</span></span></code></pre></div><h3 id=-intent-flags-예시>✅ Intent Flags 예시<a hidden class=anchor aria-hidden=true href=#-intent-flags-예시>#</a></h3><ul><li><code>Intent.FLAG_ACTIVITY_NEW_TASK</code>: 새로운 태스크에서 Activity 시작 (ex. Service에서 Activity 실행)</li><li><code>Intent.FLAG_ACTIVITY_CLEAR_TOP</code>: 스택 상에 같은 Activity가 있을 경우 해당 Activity 위의 Activity들을 제거하고 재사용</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>intent</span> <span class=p>=</span> <span class=n>Intent</span><span class=p>(</span><span class=k>this</span><span class=p>,</span> <span class=n>HomeActivity</span><span class=o>::</span><span class=k>class</span><span class=p>.</span><span class=n>java</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>intent</span><span class=p>.</span><span class=n>flags</span> <span class=p>=</span> <span class=nc>Intent</span><span class=p>.</span><span class=n>FLAG_ACTIVITY_CLEAR_TOP</span> <span class=n>or</span> <span class=nc>Intent</span><span class=p>.</span><span class=n>FLAG_ACTIVITY_SINGLE_TOP</span>
</span></span><span class=line><span class=cl><span class=n>startActivity</span><span class=p>(</span><span class=n>intent</span><span class=p>)</span>
</span></span></code></pre></div><p>Activity 간 화면 전환은 <code>Intent</code>를 통해 수행합니다. 데이터 전달도 가능합니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>intent</span> <span class=p>=</span> <span class=n>Intent</span><span class=p>(</span><span class=k>this</span><span class=p>,</span> <span class=n>DetailActivity</span><span class=o>::</span><span class=k>class</span><span class=p>.</span><span class=n>java</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>intent</span><span class=p>.</span><span class=n>putExtra</span><span class=p>(</span><span class=s2>&#34;itemId&#34;</span><span class=p>,</span> <span class=m>123</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>startActivity</span><span class=p>(</span><span class=n>intent</span><span class=p>)</span>
</span></span></code></pre></div><p>전달받는 쪽에서는 다음과 같이 처리합니다:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>itemId</span> <span class=p>=</span> <span class=n>intent</span><span class=p>.</span><span class=n>getIntExtra</span><span class=p>(</span><span class=s2>&#34;itemId&#34;</span><span class=p>,</span> <span class=p>-</span><span class=m>1</span><span class=p>)</span>
</span></span></code></pre></div><hr><h2 id=-activity에서-상태-저장하기>✅ Activity에서 상태 저장하기<a hidden class=anchor aria-hidden=true href=#-activity에서-상태-저장하기>#</a></h2><p>Android는 회전, 다크모드 변경 등 다양한 구성 변경(Configuration Change) 시 Activity를 자동으로 재생성합니다. 이때, 앱 상태를 복구하려면 <code>onSaveInstanceState()</code>와 <code>ViewModel</code>을 적절히 활용해야 합니다.</p><h3 id=-bundle-기반-임시-저장>🔁 Bundle 기반 임시 저장<a hidden class=anchor aria-hidden=true href=#-bundle-기반-임시-저장>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>override</span> <span class=k>fun</span> <span class=nf>onSaveInstanceState</span><span class=p>(</span><span class=n>outState</span><span class=p>:</span> <span class=n>Bundle</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>outState</span><span class=p>.</span><span class=n>putString</span><span class=p>(</span><span class=s2>&#34;inputText&#34;</span><span class=p>,</span> <span class=n>editText</span><span class=p>.</span><span class=n>text</span><span class=p>.</span><span class=n>toString</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=k>super</span><span class=p>.</span><span class=n>onSaveInstanceState</span><span class=p>(</span><span class=n>outState</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>override</span> <span class=k>fun</span> <span class=nf>onCreate</span><span class=p>(</span><span class=n>savedInstanceState</span><span class=p>:</span> <span class=n>Bundle</span><span class=p>?)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>super</span><span class=p>.</span><span class=n>onCreate</span><span class=p>(</span><span class=n>savedInstanceState</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>restored</span> <span class=p>=</span> <span class=n>savedInstanceState</span><span class=o>?.</span><span class=n>getString</span><span class=p>(</span><span class=s2>&#34;inputText&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>editText</span><span class=p>.</span><span class=n>setText</span><span class=p>(</span><span class=n>restored</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=-viewmodel을-통한-상태-보존-권장>✅ ViewModel을 통한 상태 보존 (권장)<a hidden class=anchor aria-hidden=true href=#-viewmodel을-통한-상태-보존-권장>#</a></h3><p>ViewModel은 Activity보다 <strong>긴 생명주기</strong>를 가지며, 구성 변경에도 데이터를 유지합니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyViewModel</span> <span class=p>:</span> <span class=n>ViewModel</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>inputText</span> <span class=p>=</span> <span class=n>MutableStateFlow</span><span class=p>(</span><span class=s2>&#34;&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>val</span> <span class=py>viewModel</span><span class=p>:</span> <span class=n>MyViewModel</span> <span class=k>by</span> <span class=n>viewModels</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>lifecycleScope</span><span class=p>.</span><span class=n>launch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>viewModel</span><span class=p>.</span><span class=n>inputText</span><span class=p>.</span><span class=n>collect</span> <span class=p>{</span> <span class=n>text</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=n>editText</span><span class=p>.</span><span class=n>setText</span><span class=p>(</span><span class=n>text</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>editText</span><span class=p>.</span><span class=n>doAfterTextChanged</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>viewModel</span><span class=p>.</span><span class=n>inputText</span><span class=p>.</span><span class=k>value</span> <span class=p>=</span> <span class=k>it</span><span class=p>.</span><span class=n>toString</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=-언제-어떤-방식-사용>🤔 언제 어떤 방식 사용?<a hidden class=anchor aria-hidden=true href=#-언제-어떤-방식-사용>#</a></h3><table><thead><tr><th>상황</th><th>Bundle</th><th>ViewModel</th></tr></thead><tbody><tr><td>임시 입력 값</td><td>✅</td><td>✅</td></tr><tr><td>대용량 데이터</td><td>❌ (제한 있음)</td><td>✅</td></tr><tr><td>화면 회전 대응</td><td>✅</td><td>✅</td></tr><tr><td>앱 재시작 대응</td><td>❌ (불가)</td><td>❌ (Room 등 외부 저장 필요)</td></tr></tbody></table><p>화면 회전 등 구성 변경(Configuration Change) 시 상태 유지를 위해 다음 콜백을 활용합니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>override</span> <span class=k>fun</span> <span class=nf>onSaveInstanceState</span><span class=p>(</span><span class=n>outState</span><span class=p>:</span> <span class=n>Bundle</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>outState</span><span class=p>.</span><span class=n>putString</span><span class=p>(</span><span class=s2>&#34;input&#34;</span><span class=p>,</span> <span class=n>editText</span><span class=p>.</span><span class=n>text</span><span class=p>.</span><span class=n>toString</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=k>super</span><span class=p>.</span><span class=n>onSaveInstanceState</span><span class=p>(</span><span class=n>outState</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>override</span> <span class=k>fun</span> <span class=nf>onCreate</span><span class=p>(</span><span class=n>savedInstanceState</span><span class=p>:</span> <span class=n>Bundle</span><span class=p>?)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>super</span><span class=p>.</span><span class=n>onCreate</span><span class=p>(</span><span class=n>savedInstanceState</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>savedText</span> <span class=p>=</span> <span class=n>savedInstanceState</span><span class=o>?.</span><span class=n>getString</span><span class=p>(</span><span class=s2>&#34;input&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><hr><h2 id=-베스트-프랙티스>✅ 베스트 프랙티스<a hidden class=anchor aria-hidden=true href=#-베스트-프랙티스>#</a></h2><ul><li><p><strong>Activity는 가볍게 유지하고</strong>, 실제 UI 로직은 Fragment, Composable에 위임하는 것이 유지 보수에 유리합니다.</p></li><li><p><strong>상태 관리</strong>는 ViewModel + StateFlow / LiveData 조합으로 처리하고, 화면 구성과 상태 흐름을 분리합니다.</p></li><li><p><strong>구성 변경 대응</strong>은 ViewModel로 하고, onSaveInstanceState는 보조 수단으로만 사용합니다.</p></li><li><p><code>onDestroy()</code>에서는 메모리 누수를 막기 위해 Listener, Receiver, Callback 등 모든 참조를 해제해야 합니다.</p></li><li><p>화면 간 전환 시 Intent를 통해 필요한 최소한의 데이터만 넘기고, 복잡한 데이터는 ViewModel이나 Repository 공유 구조를 활용합니다.</p></li><li><p>Jetpack Navigation을 도입하면 back stack 관리가 간단해지고, deep link, SafeArgs 등 다양한 기능을 손쉽게 사용할 수 있습니다.</p></li><li><p>화면 로직은 <code>Activity</code>보다 <code>Fragment</code>, <code>Composable</code>에 위임하여 <strong>책임 분리</strong></p></li><li><p>상태 관리는 <code>ViewModel</code> + <code>StateFlow</code> / <code>LiveData</code> 조합으로 처리</p></li><li><p><code>onDestroy()</code>에서는 <strong>UI 리소스만 정리</strong>하고, 앱 전역 데이터는 ViewModel이나 Repository 계층에 유지</p></li></ul><hr><h2 id=-참고-문서>📎 참고 문서<a hidden class=anchor aria-hidden=true href=#-참고-문서>#</a></h2><ul><li><a href=https://developer.android.com/guide/components/activities/intro-activities>Activity 공식 가이드</a></li><li><a href=https://developer.android.com/guide/components/activities/activity-lifecycle>Activity 생명주기</a></li><li><a href=https://developer.android.com/develop/ui/views/layout/insets-controller>Edge-to-Edge Inset 공식 가이드</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://Dax-Um.github.io/tags/android-component/>Android Component</a></li></ul><nav class=paginav><a class=next href=https://Dax-Um.github.io/posts/android-component/><span class=title>Next »</span><br><span>Android Component</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://Dax-Um.github.io/>Dax의 조용한 개발 서랍</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>